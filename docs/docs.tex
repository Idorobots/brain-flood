% Created 2013-09-25 Å›ro 12:24
\documentclass[a4paper]{article}
\usepackage{fontspec}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage[margin=2cm]{geometry}
\usepackage{amsmath}
\usepackage{minted}
\providecommand{\alert}[1]{\textbf{#1}}

\title{\textbf{Flood - User Guide}}
\author{Kajetan Rzepecki}
\date{\today}

\begin{document}

\maketitle


\vfill
\begin{center}
\includegraphics[scale=1.0]{./img/flood.png}
\end{center}

\vfill

\thispagestyle{empty}
\pagebreak

\tableofcontents

\pagebreak
\section{Introduction}
\label{sec-1}

\textbf{Flood} is a load simulator useful for automatic \textbf{Comet/PUSH application} stress-testing. It is \textbf{asynchronous, event based} and enables you to create JSON encoded \textbf{test scenarios of arbitrary complexity} involving \textbf{tens of thousands of simulated users}, no Erlang required!
\subsection{Use cases}
\label{sec-1-1}

Some of the most common use cases that \textbf{Flood} might be helpful in testing are:


\begin{itemize}
\item \textbf{Massive, real-time, on-line chats},
\item \textbf{Publisher-Subscriber channels},
\item \textbf{Instant messaging}.
\end{itemize}

\noindent
However, Flood is general enough to test \emph{any} event-based Comet application that uses the supported protocols.
\subsection{Supported Protocols}
\label{sec-1-2}

\textbf{Flood} currently supports the \textbf{Socket.IO} protocol over \textbf{WebSocket} and \textbf{XHR-polling} transports with emphasis on Socket.IO event based communication. Flood also has \emph{some} capabilities of using \textbf{raw HTTP} requests.
\subsection{Dependencies}
\label{sec-1-3}

Flood uses several awesome libraries that are listed below. Since Flood is currently in development, \emph{no particular stable versions are required} and by default the newest available versions are pulled in.


\begin{itemize}
\item Ibrowse - an HTTP client, found \href{https://github.com/cmullaparthi/ibrowse}{here}.
\item Lager - a logging framework, found \href{https://github.com/basho/lager}{here}.
\item Folsom - a metrics system, found \href{https://github.com/boundary/folsom}{here}.
\item JSONx - a fast JSON parser, found \href{https://github.com/iskra/jsonx}{here}.
\item Jesse - a JSON Schema validator, found \href{https://github.com/alertlogic/jesse}{here}.
\item \texttt{websocket\_client} - a WebSocket client, found \href{https://github.com/jeremyong/websocket_client}{here}.
\end{itemize}

\pagebreak
\section{Inner workings}
\label{sec-2}

This section describes what happens behind the scenes in \textbf{Flood} and how it reflects its usage.
\subsection{Simulated Users}
\label{sec-2-1}


\begin{itemize}
\item FSMs
\item State transitions
\end{itemize}
\subsection{User sessions}
\label{sec-2-2}
\label{ref-sessions}
\subsubsection{Session selection}
\label{sec-2-2-1}


\begin{itemize}
\item Roulette algorithm
\end{itemize}
\subsubsection{Session inheritance}
\label{sec-2-2-2}


\begin{itemize}
\item Single inheritance ordering.
\item Multiple inheritance ordering.
\item Why so OOP?
\end{itemize}
\subsubsection{Actions \& Event handlers}
\label{sec-2-2-3}


\begin{itemize}
\item on$_{\mathrm{socketio}}$
\item on$_{\mathrm{event}}$
\item on$_{\mathrm{timeout}}$
\end{itemize}
\subsubsection{Timers \& Counters}
\label{sec-2-2-4}


\begin{itemize}
\item Starting/stopping/restarting timers
\item Managing counters
\end{itemize}
\subsection{Flood phases}
\label{sec-2-3}
\label{ref-goals}



\begin{itemize}
\item Phases purpose
\item Phase goals
\end{itemize}

\pagebreak
\section{Flood scenarios}
\label{sec-3}

This section describes the Flood scenario files and gives some general guildelines for writting them. Example scenarios can be found \hyperref[sec-3-7]{here}.
\subsection{Scenario file}
\label{sec-3-1}

\textbf{Flood} uses JSON to encode test scenarios, no Erlang is required. Each scenario resides in a separate file and optionally several goal files (described in detail \hyperref[sec-4-2]{later}). The overall structure of a Flood scenario consists of three required sections:


\begin{minted}[]{javascript}
{
    "server" : {
        // Server setup.
    },

    "phases" : {
        // Test phases & goals.

        "phase_I" : {
            ...
        },
        ...
    },

    "sessions" : {
        // User session descriptions.

        "session_A" : {
            ...
        },
        ...
    }
}
\end{minted}
\subsection{Server setup}
\label{sec-3-2}

The \texttt{server} section is rather straightforward; it is used to setup the server connection. It has to define several mandatory fields:


\begin{minted}[]{javascript}
"server" : {
    "host" : "",     // The server host.
    "port" : 0,      // The server post.
    "endpoint" : "", // Endpoint used to connect to.
    "metadata" : {}  // Server-wide metadata (optional).
}
\end{minted}




\noindent
Example server configuration that will cause Flood to connect to \href{http://localhost:80/socket.io/1/}{http://localhost:80/socket.io/1/} and define some server-wide metadata (more on metadata can be found \hyperref[sec-3-6]{here}):


\begin{minted}[]{javascript}
"server" : {
    "host" : "localhost",
    "port" : 80,
    "endpoint" : "/socket.io/1/",
    "metadata" : {
        "foo" : "bar"
    }
}
\end{minted}
\subsection{Phases setup}
\label{sec-3-3}
\label{ref-phase_setup}


The \texttt{phases} section may define several arbitrarily named Flood phases. The ordering does not matter, as each phase explicitly names its start time.


\begin{minted}[]{javascript}
"phases" : {
    "A" : {
        // A's description.
    },

    "B" : {
        // B's description.
    },
    ...
}
\end{minted}




\noindent
Each phase description has to follow this format:


\begin{minted}[]{javascript}
"phase_I" : {
    "users" : 0,          // Number of users spawned during this phase.
    "user_sessions" : [], // Sessions spawned users should follow.

    "start_time" : 0,     // Time (in milliseconds) at which to start this phase.
    "spawn_duration" : 0, // Duration (in milliseconds) Flood should take to spawn the users.

    "goal" : {},          // Goal of this phase (optional).
    "test_interval" : 0,  // Interval (in milliseconds) of the goal checks (optional).
    "timeout" : 0,        // Timeout (in milliseconds) of this phase (optional).

    "metadata" : {}       // Phase-wide metadata (optional).
}
\end{minted}




\noindent
The meaning of each of the fields is as follows:


\begin{itemize}
\item \texttt{users} - an integer number of users spawned during this phase. It is \textbf{mandatory}.
\item \texttt{user\_sessions} - a array of Flood user session names; the concrete user session will be selected at \textbf{random according to a sessions weight} (more about this can be found \hyperref[sec-2-2]{here}). It is \textbf{mandatory}.
\item \texttt{start\_time} - an integer value that names a point in time (\textbf{in milliseconds}), relative to the start of the Flood, at which a phase should be started. It is \textbf{mandatory}.
\item \texttt{spawn\_duration} - an integer value that tells Flood how much time (\textbf{in milliseconds}) it should take to spawn \texttt{users} number of users. Users are spawned uniformly throughout this duration. Keep in mind that for various performance related reasons Flood \textbf{may actually take longer} to spawn the users, however it will never take less time to do so. This field is \textbf{mandatory}.
\item \texttt{goal} - either an arbitrary JSON term that is a description of the goal of this phase (more on goals can be found \hyperref[sec-2-3]{here}) or a string containing a path to the file containing the goal description relative to scenario file. This field is \textbf{optional}; not defining it will result in no goal checking whatsoever.
\item \texttt{test\_interval} - an integer value that tells Flood at what intervals (\textbf{in milliseconds}) in should check whether the \texttt{goal} has been reached. It is \textbf{optional}; not defining it will result in a single check at the phase \texttt{timeout}.
\item \texttt{timeout} - an integer value that names a point in time (\textbf{in milliseconds}), relative to the start of the Flood, at which a phase should be terminated if it is still running. It is \textbf{optional}.
\item \texttt{metadata} - a JSON object defining some phase-wide metadata (more on metadata \hyperref[sec-3-6]{later}). It is \textbf{optional}.
\end{itemize}

\noindent
Example \texttt{phases} setup:


\begin{minted}[]{javascript}
"phases" : {
    "phase_I" : {
        "metadata" : { },

        "users" : 1000,
        "user_sessions" : ["session_A", "session_B"],

        "start_time" : 1000,
        "spawn_duration" : 1000
    },

    "phase_II" : {
        "metadata" : { },

        "users" : 1000,
        "user_sessions" : ["session_C"],

        "start_time" : 2000,
        "spawn_duration" : 5000

        "goal" : "./goal.jsonschema",
        "test_interval" : 100,
        "timeout" : 10000
    }
}
\end{minted}




\noindent
This setup will schedule two Flood phases. The first phase, \texttt{phase\_I}, will start at 1000 ms and spawn 1000 users following either \texttt{session\_A} or \texttt{session\_B} over 1000 ms duration. The second phase, \texttt{phase\_II}, will start at 2000 ms and spawn 1000 users following \texttt{session\_C} over 5000 ms duration. Additionally, a \texttt{phase\_II} goal check will be scheduled every 100 ms starting at 2000 ms and running util the goal provided in ``./goal.jsonschema'' file is met or until the phase timeout, set at 10000 ms, is reached.
\subsection{User session setup}
\label{sec-3-4}
\label{ref-session_setup}


The \texttt{sessions} section may define several arbitrarily named Flood user sessions. The ordering does not matter, as each session explicitly names its relations to other sessions.


\begin{minted}[]{javascript}
"sessions" : {
    "session_A" : {
        // A's description.
    },

    "session_B" : {
        // B's description.
    },
    ...
}
\end{minted}




\noindent
Each session description has to follow this format:


\begin{minted}[]{javascript}
"session_A" : {
    "extends" : [],   // Array of sessions extended by this session (optional).

    "weight" : 0.0,   // Weight of this session (optional).
    "transport" : "", // Socket.IO transport used by this session (optional).

    "metadata" : {},  // Session-wide metadata (optional).
    "do" : []         // Array of actions to be performed by the user (optional).
}
\end{minted}




\noindent
The meaning of each of the fields is as follows:


\begin{itemize}
\item \texttt{extends} - an array of session names that this session extends (more about session inheritance can be found \hyperref[sec-2-2]{here}). It is \textbf{optional} and omitting it means that this session does not extend any other sessions.
\item \texttt{weight} - a real number determining how often simulated users will choose this session over other sessions (more on session selection can be found \hyperref[sec-2-2]{here}); it is completely relative and depends on the total weight of a subset of sessions considered at one point (for examples at a certain Flood phase's startup). It is \textbf{optional} and defaults to \textbf{0.0}.
\item \texttt{transport} - a string naming a Socket.IO compatible transport protocol. It should be either of \texttt{websocket} or \texttt{xhr-polling}, but in general it is \textbf{optional} and defaults to the empty string.
\item \texttt{metadata} - a JSON object defining some session-wide metadata (more on metadata \hyperref[sec-3-6]{later}). It is \textbf{optional}.
\item \texttt{do} - an array of actions to be performed by the users following this session (more on actions \& event handlers can be found \hyperref[sec-2-2]{here}; a list of all available actions can be found in the next section). It is \textbf{optional} and defaults to the empty array.
\end{itemize}
\subsection{User actions}
\label{sec-3-5}

Actions are performed by the simulated users after their initialization and whenever an event triggers an event handler (for example, a Socket.IO message is received or a timer is due). Actions \textbf{ordering does matter} as some actions change the state of the simulated users.

\noindent
Actions are represented as short JSON arrays consisting of an \texttt{action\_ID} and a JSON object listing actions \texttt{arguments}:


\begin{minted}[]{javascript}
["action_ID", {
    "argument_1" : "value_1", // Argument ordering does not matter.
    "argument_2" : "value_2",
    ...
}]
\end{minted}




\noindent
For convenience, some actions define a shorter forms that mean exactly the same, for example:


\begin{minted}[]{javascript}
["action_ID", "value_1", "value_2"] // Mind the arguments ordering.
\end{minted}




\noindent
The following list lists available actions, describes their effects and arguments, and gives an example invocation in both full and short forms:


\begin{itemize}
\item \texttt{inc} - increments a named counter either by 1 or by \texttt{Value}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["inc", "counter_name"]
["inc", "counter_name", Value]
["inc", {
    "name" : "counter_name",
    "value" : Value
}]
\end{minted}





\begin{itemize}
\item \texttt{dec} - decrements a named counter either by 1 or by \texttt{Value}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["dec", "counter_name"]
["dec", "counter_name", Value]
["dec", {
    "name" : "counter_name",
    "value" Value
}]
\end{minted}





\begin{itemize}
\item \texttt{set} - sets a named counter to a given \texttt{Value}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["set", "counter_name", Value]
["set", {
    "name" : "counter_name",
    "value" : Value
}]
\end{minted}





\begin{itemize}
\item \texttt{start\_timer} - starts a named timer timeouting in \texttt{Timeout} milliseconds. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["start_timer", "timer_name", Timeout]
["start_timer", {
    "name" : "timer_name",
    "time" : Timeout
}]
\end{minted}





\begin{itemize}
\item \texttt{stop\_timer} - stops a named timer preventing it from timing out and triggering an event dispatch. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["stop_timer", "timer_name"]
["stop_timer", {
    "name" : "timer_name"
}]
\end{minted}





\begin{itemize}
\item \texttt{restart\_timer} - restarts a named timer. Essentially, performs \texttt{stop\_timer} and \texttt{start\_timer} is quick succession. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["restart_timer", "timer_name", Timeout]
["restart_timer", {
    "name" : "timer_name",
    "time" : Timeout
}]
\end{minted}





\begin{itemize}
\item \texttt{timed} - executes a set of actions while timing their execution time which it then stores is a named counter. Results in whatever the actions result in. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["timed", {
    "name" : "counter_name",
    "do" : [
        Action,
        ...
    ]
}]
\end{minted}





\begin{itemize}
\item \texttt{on\_timeout} - adds several timeout handlers to the simulated users state. If a given timeout handler already exists, new actions are appended \textbf{after} the existing ones, meaning they will be executed after the existing actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["on_timeout", {
    "timer_name_1" : [
        Action,
        ...
    ],
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{on\_event} - adds several event handlers to the simulated users state. If a given event handler already exists, new actions are appended \textbf{after} the existing ones, meaning they will be executed after the existing actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["on_event", {
    "event_1" : [
        Action,
            ...
    ],
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{on\_socketio} - adds several messages handlers to the simulated users state. If a given message handler already exists, new actions are appended \textbf{after} the existing ones, meaning they will be executed after the existing actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["on_socketio", {
    "opcode_1" : [
        Action,
            ...
    ],
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{emit\_event} - emits \texttt{Event} with \texttt{Args} as a Socket.IO message with the event opcode. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["emit_event", {
    "name" : Event,
    "args" : Args
}]
\end{minted}





\begin{itemize}
\item \texttt{emit\_socketio} - emits a Socket.IO message to the given \texttt{Endpoint} with the given \texttt{Opcode} and \texttt{Payload}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["emit_socketio", {
    "opcode" : Opcode,
    "endpoint" : Endpoint,
    "data" : Payload
}]
\end{minted}





\begin{itemize}
\item \texttt{emit\_http} - emits a synchronous HTTP request with a given \texttt{Method}, \texttt{Body}, \texttt{Headers} and \texttt{Timeout} to a given \texttt{Url}. Afterwards, executes actions defined in \texttt{on\_reply} or \texttt{on\_error} when the requests succeeded or failed respectively. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["emit_http", {
    "url" : Url,
    "method" : Method,
    "body" : Body,
    "headers" : Headers,
    "timeout" : Timeout,

    "on_reply" : [
        Action,
        ...
    ],

    "on_error" : [
        Action,
        ...
    ]
}]
\end{minted}





\begin{itemize}
\item \texttt{match} - performs either a JSON-based or RegExp-based pattern-matching operation on \texttt{Subject}. RegExp-based matching takes precedence over JSON-based matching. The results are stored in the simulated users metadata under \texttt{Name\_\#} (where \# is the index of the match) for RegExp-based matching or under respective \texttt{\$names} for JSON-based matching. Afterwards, executes actions defined in either \texttt{on\_match} or \texttt{on\_nomatch} when the matching succeeds or fails respectively. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["match", {
    "name" : Name,
    "subject" : Subject,
    "re" : "regexp",

    "on_match" : [
        Action,
        ...
    ],

    "on_nomatch" : [
        Action,
        ...
    ]
}]

["match", {
    "subject" : Subject,
    "json" : {
        "field_1" : "$value_1",
        "field_2" : "$value_2",
        ...
    },

    "on_match" : [
        Action,
        ...
    ],

    "on_nomatch" : [
        Action,
        ...
    ]
}]
\end{minted}





\begin{itemize}
\item \texttt{case} - performs a value case dispatch on a given \texttt{Value} selecting a matching \texttt{Branch} and executing its respective actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["case", Value, {
    Branch : [
        Action,
        ...
    ],
    ...
}]
["case", {
    "condition" : Value,
    "branches" : {
        Branch : [
            Action,
            ...
        ],
        ...
    }
}]
\end{minted}





\begin{itemize}
\item \texttt{def} - adds new metadata to the simulated users state. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["def", {
    "key_1" : "value_1",
    "key_2" : "value_2",
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{terminate} - immediately stops actions execution and terminates the simulated user with termination reason set to \texttt{Reason}. Disconnects him from the server and terminates his process. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["terminate", Reason]
["terminate", {
    "reason" : Reason
}]
\end{minted}





\begin{itemize}
\item \texttt{log} - prints a log line to the console formatting it with the \texttt{Format} and \texttt{Values}. The \texttt{Format} format is the same as Erlangs \texttt{io:format/2} (why yes, I did lie about the ``no Erlang required'' thing, deal with it). Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["log", Format, Values]
["log", {
    "format" : Format,
    "values" : Values
}]
\end{minted}





\begin{itemize}
\item \texttt{!log} - a convenience action that allows easy \texttt{log} toggling; does nothing. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["!log", Format, Values]
["!log", {
    "format" : Format,
    "values" : Values
}]
\end{minted}
\subsection{Metadata}
\label{sec-3-6}
\label{ref-metadata}


\textbf{Flood} provides a per-user key-value store that can be accessed later by the simulated users. Various parts of a Flood scenario may define arbitrary key-value pairs in the \texttt{metadata} field. For example:


\begin{minted}[]{javascript}
"metadata" : {
    "foo" : "bar",
    "bar" : [1, 2, 3],
    ...
}
\end{minted}




\noindent
Metadada defined in different sections has different scope. The \texttt{server} metadata is accessible by all the users. The \texttt{phase} metadata is accessible by the users spawned in that particular phase and \texttt{session} metadata is accessible by all the users following that metadata.

\noindent
Metadata is \textbf{not shared} between users, instead every user accesses a unique copy. That means that the metadada can be freely modified added and removed during simulated users execution. This is the so-called \emph{run-time metadata}.

\noindent
Metadada from different sections \textbf{can and will shadow} metadada from other sections, the order is as follows (accessed from left to right):


\begin{minted}[]{javascript}
run-time metadata >> session metadata >> phase metadata >> server metadata
\end{minted}




\noindent
Metadata can be accessed freely using \emph{JSON \$ubstitutions}:


\begin{minted}[]{javascript}
["emit_event", {
    "name" : "$foo", // $foo --> "bar"
    "args" : "$bar"  // $bar --> [1, 2, 3]
}]
\end{minted}




\noindent
In general, JSON \$ubstitutions can be used anywhere in the value position with the exception of \textbf{arrays of actions}, which are not substituted because they may contain their own \$ubstitutions:


\begin{minted}[]{javascript}
"do" : [
    "$some_action",                 // Not substituted.
    ["start_timer", "$timer", 1000] // Will be substituted when start_timer is executed.
]
\end{minted}




\noindent
There is some metadata that is added to the client state by default. Most of these correspond directly to the setup of different scenario sections:


\begin{itemize}
\item \texttt{server.host} - the server host,
\item \texttt{server.port} - the server port,
\item \texttt{server.endpoint} - the server endpointt,
\item \texttt{server.url} - the server URL (host:port/endpoint),
\item \texttt{server.sid} - the Socket.IO session ID received from the server,
\item \texttt{server.heartbeat\_timeout} - the Socket.IO heartbeat timeout received from the server,
\item \texttt{server.reconnect\_timeout} - the Socket.IO reconnect timeout received from the server,
\item \texttt{server.available\_transports} - the Socket.IO transports supported by the server,
\item \texttt{phase.name} - the name of the \emph{phase} the user was spawned in,
\item \texttt{phase.users} - the number of users spawned in this \emph{phase},
\item \texttt{phase.user\_sessions} - the user sessions used in this \emph{phase},
\item \texttt{phase.start\_time} - the start time of this \emph{phase},
\item \texttt{phase.spawn\_duration} - the user spawn duration of this \emph{phase},
\item \texttt{phase.test\_interval} - the goal check interval of this \emph{phase},
\item \texttt{phase.timeout} - the timeout time of this \emph{phase},
\item \texttt{phase.goal} - the goal of this \emph{phase},
\item \texttt{session.name} - the name of the \emph{session} the user is following,
\item \texttt{session.base\_sessions} - the array of sessions extended by this \emph{session},
\item \texttt{session.transport} - the Socket.IO transport used by this \emph{session},
\item \texttt{session.weight} - the weight of this \emph{session}.
\end{itemize}
\subsection{Example scenarios}
\label{sec-3-7}
\label{ref-example_scenarios}
\subsubsection{Session inheritance}
\label{sec-3-7-1}

This example shows session inheritance usage (more on this \hyperref[sec-2-2]{here}). Full Flood scenario:


\begin{minted}[]{javascript}
{
    "server" : {
        "host" : "localhost",
        "port" : 8080,
        "endpoint" : "/socket.io/1/"
    },

    "phases" : {
        "phase_I" : {
            "users" : 1,
            "user_sessions" : ["e"],

            "start_time" : 1000,
            "spawn_duration" : 1000,

            "timeout" : 3000
        }
    },

    "sessions" : {
        "a" : {
            "do" : [["log", "In A!"]]
        },

        "b" : {
            "extends" : ["a"],
            "do" : [["log", "In B!"]]
        },

        "c" : {
            "extends" : ["a"],
            "do" : [["log", "In C!"]]
        },

        "d" : {
            "extends" : ["b", "c"],
            "do" : [["log", "In D!"]]
        },

        "e" : {
            "weight" : 1.0,
            "transport" : "websocket",

            "extends" : ["d", "c", "b"],
            "do" : [["log", "In E!"]]
        }
    }
}
\end{minted}




\noindent
Sessions are composed retaining their topological ordering what ensures \emph{sane} execution:

\begin{itemize}
\item session \texttt{e} extends \texttt{d}, \texttt{c} and \texttt{b} and requires them to run first \textbf{in order},
\item session \texttt{d} extends \texttt{b} and \texttt{c},
\item session \texttt{e} ensures that \texttt{b} and \texttt{c} \emph{will} run, so \texttt{d} doesn't need to run \texttt{b} nor \texttt{c},
\item sessions \texttt{b} and \texttt{c} extend \texttt{a},
\item since session \texttt{d} requires both \texttt{b} and \texttt{c} to run and since \texttt{e} ensures that \texttt{b} and \texttt{c} \emph{will} run, \texttt{d} only requires \texttt{a} to run first.
\end{itemize}

\noindent
Flood output:


\begin{verbatim}
10:34:01.684 [notice] Running test examples/1.json
10:34:01.712 [notice] Scheduling Flood phase phase_I: 1 users every 1000 msecs (1 max)
                      starting at 1000 ms.
10:34:01.712 [notice] Scheduling Flood phase phase_I test at 3000 ms.
10:34:02.729 [notice] In A!
10:34:02.729 [notice] In D!
10:34:02.729 [notice] In C!
10:34:02.729 [notice] In B!
10:34:02.729 [notice] In E!
10:34:04.722 [notice] Flood phase phase_I reached its goal!
\end{verbatim}
\subsubsection{Ping-Pong}
\label{sec-3-7-2}

This example is a little more involved, it spawns 1000 users that ping a test server and measure the response time. It shows timers \& counters usage (more on timers \& counters \hyperref[sec-2-2]{here}). Full Flood scenario:


\begin{minted}[]{javascript}
{
    "server" : {
        "host" : "localhost",
        "port" : 8080,
        "endpoint" : "/socket.io/1/"
    },

    "phases" : {
        "pingers" : {
            "users" : 1000,
            "user_sessions" : ["pinger"],

            "start_time" : 100,
            "spawn_duration" : 100,

            "test_interval" : 100,
            "timeout" : 10000,

            "goal" : {
                "type" : "object",
                "properties" : {
                    "counters" : {
                        "type" : "object",
                        "properties" : {
                            "received" : {
                                "type" : "integer",
                                "minimum" : 1000,
                                "required" : true
                            },
                            "sent" : {
                                "type" : "integer",
                                "minimum" : 1000,
                                "required" : true
                            }
                        }
                    },
                    "timers" : {
                        "type" : "object"
                    }
                }
            },

            "metadata" : {
                "ping_timeout" : 1000
            }
        }
    },

    "sessions" : {
        "pinger" : {
            "transport" : "websocket",
            "weight" : 0.8,

            "do" : [
                ["on_socketio", {
                    "1" : [
                        ["log", "Ping ~s!", ["$server.sid"]],
                        ["emit_event", {
                            "name" : "ping",
                            "args" : ["$server.sid"]
                        }],
                        ["inc", "sent"],
                        ["start_timer", "ping", "$ping_timeout"]
                    ],

                    "5" : [
                        ["inc", "received"],
                        ["log", "Pong ~s!", ["$message.data"]],
                        ["stop_timer", "ping"]
                    ]
                }],
                ["on_timeout", {
                    "ping" : [
                        ["log", "Ping timeouted for ~s!", ["$server.sid"]]
                    ]
                }]
            ]
        }
    }
}
\end{minted}




\noindent
Flood output:


\begin{verbatim}
11:38:31.902 [notice] Running test examples/2.json
11:38:31.923 [notice] Scheduling Flood phase pingers: 100 users every 10 msecs (1000 max)
                      starting at 100 ms.
11:38:31.923 [notice] Scheduling Flood phase pingers test every 100 ms starting at 100 ms,
                      with timeout at 10000 ms.
11:38:32.254 [notice] Ping 912feef519889dd9866fbfaea6bfeb96218d7ce!
...
11:38:32.341 [notice] Pong {"name":"ping","args":["912feef519889dd9866fbfaea6bfeb96218d7ce"]}!
...
11:38:34.296 [notice] Flood phase pingers reached its goal!
\end{verbatim}



\noindent
Flood results show exactly how the server behaved, with minimal request processing time (with IO time) at 54 ms and maximum processing time at 523 ms (more on flood results can be found \hyperref[sec-4]{here}). Additionally, various statistics are provided:


\begin{minted}[]{javascript}
{
    "counters" : {
        "ws_incomming" : 2000,
        "http_outgoing" : 1000,
        "ws_outgoing" : 1000,
        "http_incomming" : 1000,
        "disconnected_users" : 0,
        "connected_users" : 1000,
        "pingers_goal_time" : 1900,
        "alive_users" : 1000,
        "all_users" : 1000,
        "terminated_users" : 0,
        "received" : 1000,
        "sent" : 1000
    },
    "timers" : {
        "ping" : {
            "min" : 54,
            "max" : 523,
            "arithmetic_mean" : 298.8575,
            "geometric_mean" : 260.985015508945,
            "harmonic_mean" : 216.292895973774,
            "median" : 347,
            "variance" : 17071.5510714286,
            "standard_deviation" : 130.658145828833,
            "skewness" : -0.387733104425692,
            "kurtosis" : -1.27787946255272,
            "percentile" : {
                "50" : 347,
                "75" : 401,
                "90" : 447,
                "95" : 463,
                "99" : 504,
                "999" : 523
            },
            "histogram" : {
                "x" : [124,184,244,304,364,454,554,654],
                "y" : [52,75,8,18,83,135,29,0]
            },
            "n" : 400
        }
    }
}
\end{minted}
\subsubsection{More examples}
\label{sec-3-7-3}

More Flood scenario examples and their results can be found in th \texttt{examples} directory of the Flood repository.

\pagebreak
\section{Flood results}
\label{sec-4}
\label{ref-results}
\subsection{Results format}
\label{sec-4-1}


\begin{itemize}
\item JSON structure
\item Counters
\item Timers
\item Available statistics
\end{itemize}
\subsection{Goal schemas}
\label{sec-4-2}
\label{ref-goal_schemas}


\begin{itemize}
\item JSON Schema structure
\item Testing intervals
\item Reaching goals
\item Goal timeouts
\end{itemize}
\subsection{Continuous Integration integration}
\label{sec-4-3}


\begin{itemize}
\item Running Flood automagically
\end{itemize}
\subsection{Example results}
\label{sec-4-4}
\label{ref-example_results}



\begin{itemize}
\item Sessions
\item Single ping
\item Continuous ping
\item ``3rd party'' requests
\end{itemize}

\end{document}
