% Created 2013-09-24 wto 15:52
\documentclass[a4paper]{article}
\usepackage{fontspec}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage[margin=2cm]{geometry}
\usepackage{amsmath}
\usepackage{minted}
\providecommand{\alert}[1]{\textbf{#1}}

\title{\textbf{Flood - User Guide}}
\author{Kajetan Rzepecki}
\date{\today}

\begin{document}

\maketitle


\vfill
\begin{center}
\includegraphics[scale=1.0]{./img/flood.png}
\end{center}

\vfill

\thispagestyle{empty}
\pagebreak

\tableofcontents

\pagebreak
\section{Introduction}
\label{sec-1}

\textbf{Flood} is a load simulator useful for automatic \textbf{Comet/PUSH application} stress-testing. It is \textbf{asynchronous, event based} and enables you to create JSON encoded \textbf{test scenarios of arbitrary complexity} involving \textbf{tens of thousands of simulated users}, no Erlang required!
\subsection{Use cases}
\label{sec-1-1}

Some of the most common use cases that \textbf{Flood} might be helpful in testing are:


\begin{itemize}
\item \textbf{Massive, real-time, on-line chats},
\item \textbf{Publisher-Subscriber channels},
\item \textbf{Instant messaging}.
\end{itemize}

\noindent
However, Flood is general enough to test \emph{any} event-based Comet application that uses the supported protocols.
\subsection{Supported Protocols}
\label{sec-1-2}

\textbf{Flood} currently supports the \textbf{Socket.IO} protocol over \textbf{WebSocket} and \textbf{XHR-polling} transports with emphasis on Socket.IO event based communication. Flood also has \emph{some} capabilities of using \textbf{raw HTTP} requests.
\subsection{Dependencies}
\label{sec-1-3}

Flood uses several awesome libraries that are listed below. Since Flood is currently in development, \emph{no particular stable versions are required} and by default the newest available versions are pulled in.


\begin{itemize}
\item Ibrowse - an HTTP client, found \href{https://github.com/cmullaparthi/ibrowse}{here}.
\item Lager - a logging framework, found \href{https://github.com/basho/lager}{here}.
\item Folsom - a metrics system, found \href{https://github.com/boundary/folsom}{here}.
\item JSONx - a fast JSON parser, found \href{https://github.com/iskra/jsonx}{here}.
\item Jesse - a JSON Schema validator, found \href{https://github.com/alertlogic/jesse}{here}.
\item \texttt{websocket\_client} - a WebSocket client, found \href{https://github.com/jeremyong/websocket_client}{here}.
\end{itemize}

\pagebreak
\section{Inner workings}
\label{sec-2}

This section describes what happens behind the scenes in \textbf{Flood} and how it reflects its usage.
\subsection{Simulated Users}
\label{sec-2-1}


\begin{itemize}
\item FSMs
\item State transitions
\end{itemize}
\subsection{User sessions}
\label{sec-2-2}
\label{ref-sessions}
\subsubsection{Session selection}
\label{sec-2-2-1}


\begin{itemize}
\item Roulette algorithm
\end{itemize}
\subsubsection{Session inheritance}
\label{sec-2-2-2}


\begin{itemize}
\item Single inheritance ordering.
\item Multiple inheritance ordering.
\item Why so OOP?
\end{itemize}
\subsubsection{Actions \& Event handlers}
\label{sec-2-2-3}


\begin{itemize}
\item on$_{\mathrm{socketio}}$
\item on$_{\mathrm{event}}$
\item on$_{\mathrm{timeout}}$
\end{itemize}
\subsubsection{Timers \& Counters}
\label{sec-2-2-4}


\begin{itemize}
\item Starting/stopping/restarting timers
\item Managing counters
\end{itemize}
\subsection{Flood phases}
\label{sec-2-3}
\label{ref-goals}



\begin{itemize}
\item Phases purpose
\item Phase goals
\end{itemize}

\pagebreak
\section{Flood scenarios}
\label{sec-3}

This section describes the Flood scenario files and gives some general guildelines for writting them. Example scenarios can be found \hyperref[sec-3-7]{here}.
\subsection{Scenario file}
\label{sec-3-1}

\textbf{Flood} uses JSON to encode test scenarios, no Erlang is required. Each scenario resides in a separate file and optionally several goal files (described in detail \hyperref[sec-4-2]{later}). The overall structure of a Flood scenario consists of three required sections:


\begin{minted}[]{javascript}
{
    "server" : {
        // Server setup.
    },

    "phases" : {
        // Test phases & goals.

        "phase_I" : {
            ...
        },
        ...
    },

    "sessions" : {
        // User session descriptions.

        "session_A" : {
            ...
        },
        ...
    }
}
\end{minted}
\subsection{Server setup}
\label{sec-3-2}

The \texttt{server} section is rather straightforward; it is used to setup the server connection. It has to define several mandatory fields:


\begin{minted}[]{javascript}
"server" : {
    "host" : "",     // The server host.
    "port" : 0,      // The server post.
    "endpoint" : "", // Endpoint used to connect to.
    "metadata" : {}  // Server-wide metadata (optional).
}
\end{minted}




\noindent
Example server configuration that will cause Flood to connect to \href{http://localhost:80/socket.io/1/}{http://localhost:80/socket.io/1/} and define some server-wide metadata (more on metadata can be found \hyperref[sec-3-6]{here}):


\begin{minted}[]{javascript}
"server" : {
    "host" : "localhost",
    "port" : 80,
    "endpoint" : "/socket.io/1/",
    "metadata" : {
        "foo" : "bar"
    }
}
\end{minted}
\subsection{Phases setup}
\label{sec-3-3}
\label{ref-phase_setup}


The \texttt{phases} section may define several arbitrarily named Flood phases. The ordering does not matter, as each phase explicitly names its start time.


\begin{minted}[]{javascript}
"phases" : {
    "A" : {
        // A's description.
    },

    "B" : {
        // B's description.
    },
    ...
}
\end{minted}




\noindent
Each phase description has to follow this format:


\begin{minted}[]{javascript}
"phase_I" : {
    "users" : 0,          // Number of users spawned during this phase.
    "user_sessions" : [], // Sessions spawned users should follow.

    "start_time" : 0,     // Time (in milliseconds) at which to start this phase.
    "spawn_duration" : 0, // Duration (in milliseconds) Flood should take to spawn the users.

    "goal" : {},          // Goal of this phase (optional).
    "test_interval" : 0,  // Interval (in milliseconds) of the goal checks (optional).
    "timeout" : 0,        // Timeout (in milliseconds) of this phase (optional).

    "metadata" : {}       // Phase-wide metadata (optional).
}
\end{minted}




\noindent
The meaning of each of the fields is as follows:


\begin{itemize}
\item \texttt{users} - an integer number of users spawned during this phase. It is \textbf{mandatory}.
\item \texttt{user\_sessions} - a array of Flood user session names; the concrete user session will be selected at \textbf{random according to a sessions weight} (more about this can be found \hyperref[sec-2-2]{here}). It is \textbf{mandatory}.
\item \texttt{start\_time} - an integer value that names a point in time (\textbf{in milliseconds}), relative to the start of the Flood, at which a phase should be started. It is \textbf{mandatory}.
\item \texttt{spawn\_duration} - an integer value that tells Flood how much time (\textbf{in milliseconds}) it should take to spawn \texttt{users} number of users. Users are spawned uniformly throughout this duration. Keep in mind that for various performance related reasons Flood \textbf{may actually take longer} to spawn the users, however it will never take less time to do so. This field is \textbf{mandatory}.
\item \texttt{goal} - either an arbitrary JSON term that is a description of the goal of this phase (more on goals can be found \hyperref[sec-2-3]{here}) or a string containing a path to the file containing the goal description relative to scenario file. This field is \textbf{optional}; not defining it will result in no goal checking whatsoever.
\item \texttt{test\_interval} - an integer value that tells Flood at what intervals (\textbf{in milliseconds}) in should check whether the \texttt{goal} has been reached. It is \textbf{optional}; not defining it will result in a single check at the phase \texttt{timeout}.
\item \texttt{timeout} - an integer value that names a point in time (\textbf{in milliseconds}), relative to the start of the Flood, at which a phase should be terminated if it is still running. It is \textbf{optional}.
\item \texttt{metadata} - a JSON object defining some phase-wide metadata (more on metadata \hyperref[sec-3-6]{later}). It is \textbf{optional}.
\end{itemize}

\noindent
Example \texttt{phases} setup:


\begin{minted}[]{javascript}
"phases" : {
    "phase_I" : {
        "metadata" : { },

        "users" : 1000,
        "user_sessions" : ["session_A", "session_B"],

        "start_time" : 1000,
        "spawn_duration" : 1000
    },

    "phase_II" : {
        "metadata" : { },

        "users" : 1000,
        "user_sessions" : ["session_C"],

        "start_time" : 2000,
        "spawn_duration" : 5000

        "goal" : "./goal.jsonschema",
        "test_interval" : 100,
        "timeout" : 10000
    }
}
\end{minted}




\noindent
This setup will schedule two Flood phases. The first phase, \texttt{phase\_I}, will start at 1000 ms and spawn 1000 users following either \texttt{session\_A} or \texttt{session\_B} over 1000 ms duration. The second phase, \texttt{phase\_II}, will start at 2000 ms and spawn 1000 users following \texttt{session\_C} over 5000 ms duration. Additionally, a \texttt{phase\_II} goal check will be scheduled every 100 ms starting at 2000 ms and running util the goal provided in ``./goal.jsonschema'' file is met or until the phase timeout, set at 10000 ms, is reached.
\subsection{User session setup}
\label{sec-3-4}
\label{ref-session_setup}


The \texttt{sessions} section may define several arbitrarily named Flood user sessions. The ordering does not matter, as each session explicitly names its relations to other sessions.


\begin{minted}[]{javascript}
"sessions" : {
    "session_A" : {
        // A's description.
    },

    "session_B" : {
        // B's description.
    },
    ...
}
\end{minted}




\noindent
Each session description has to follow this format:


\begin{minted}[]{javascript}
"session_A" : {
    "extends" : [],   // Array of sessions extended by this session (optional).

    "weight" : 0.0,   // Weight of this session (optional).
    "transport" : "", // Socket.IO transport used by this session (optional).

    "metadata" : {},  // Session-wide metadata (optional).
    "do" : []         // Array of actions to be performed by the user (optional).
}
\end{minted}




\noindent
The meaning of each of the fields is as follows:


\begin{itemize}
\item \texttt{extends} - an array of session names that this session extends (more about session inheritance can be found \hyperref[sec-2-2]{here}). It is \textbf{optional} and omitting it means that this session does not extend any other sessions.
\item \texttt{weight} - a real number determining how often simulated users will choose this session over other sessions (more on session selection can be found \hyperref[sec-2-2]{here}); it is completely relative and depends on the total weight of a subset of sessions considered at one point (for examples at a certain Flood phase's startup). It is \textbf{optional} and defaults to \textbf{0.0}.
\item \texttt{transport} - a string naming a Socket.IO compatible transport protocol. It should be either of \texttt{websocket} or \texttt{xhr-polling}, but in general it is \textbf{optional} and defaults to the empty string.
\item \texttt{metadata} - a JSON object defining some session-wide metadata (more on metadata \hyperref[sec-3-6]{later}). It is \textbf{optional}.
\item \texttt{do} - an array of actions to be performed by the users following this session (more on actions \& event handlers can be found \hyperref[sec-2-2]{here}; a list of all available actions can be found in the next section). It is \textbf{optional} and defaults to the empty array.
\end{itemize}
\subsection{User actions}
\label{sec-3-5}

Actions are performed by the simulated users after their initialization and whenever an event triggers an event handler (for example, a Socket.IO message is received or a timer is due). Actions \textbf{ordering does matter} as some actions change the state of the simulated users.

\noindent
Actions are represented as short JSON arrays consisting of an \texttt{action\_ID} and a JSON object listing actions \texttt{arguments}:


\begin{minted}[]{javascript}
["action_ID", {
    "argument_1" : "value_1", // Argument ordering does not matter.
    "argument_2" : "value_2",
    ...
}]
\end{minted}




\noindent
For convenience, some actions define a shorter forms that mean exactly the same, for example:


\begin{minted}[]{javascript}
["action_ID", "value_1", "value_2"] // Mind the arguments ordering.
\end{minted}




\noindent
The following list lists available actions, describes their effects and arguments, and gives an example invocation in both full and short forms:


\begin{itemize}
\item \texttt{inc} - increments a named counter either by 1 or by \texttt{Value}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["inc", "counter_name"]
["inc", "counter_name", Value]
["inc", {
    "name" : "counter_name",
    "value" : Value
}]
\end{minted}





\begin{itemize}
\item \texttt{dec} - decrements a named counter either by 1 or by \texttt{Value}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["dec", "counter_name"]
["dec", "counter_name", Value]
["dec", {
    "name" : "counter_name",
    "value" Value
}]
\end{minted}





\begin{itemize}
\item \texttt{set} - sets a named counter to a given \texttt{Value}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["set", "counter_name", Value]
["set", {
    "name" : "counter_name",
    "value" : Value
}]
\end{minted}





\begin{itemize}
\item \texttt{start\_timer} - starts a named timer timeouting in \texttt{Timeout} milliseconds. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["start_timer", "timer_name", Timeout]
["start_timer", {
    "name" : "timer_name",
    "time" : Timeout
}]
\end{minted}





\begin{itemize}
\item \texttt{stop\_timer} - stops a named timer preventing it from timing out and triggering an event dispatch. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["stop_timer", "timer_name"]
["stop_timer", {
    "name" : "timer_name"
}]
\end{minted}





\begin{itemize}
\item \texttt{restart\_timer} - restarts a named timer. Essentially, performs \texttt{stop\_timer} and \texttt{start\_timer} is quick succession. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["restart_timer", "timer_name", Timeout]
["restart_timer", {
    "name" : "timer_name",
    "time" : Timeout
}]
\end{minted}





\begin{itemize}
\item \texttt{timed} - executes a set of actions while timing their execution time which it then stores is a named counter. Results in whatever the actions result in. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["timed", {
    "name" : "counter_name",
    "do" : [
        Action,
        ...
    ]
}]
\end{minted}





\begin{itemize}
\item \texttt{on\_timeout} - adds several timeout handlers to the simulated users state. If a given timeout handler already exists, new actions are appended \textbf{after} the existing ones, meaning they will be executed after the existing actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["on_timeout", {
    "timer_name_1" : [
        Action,
        ...
    ],
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{on\_event} - adds several event handlers to the simulated users state. If a given event handler already exists, new actions are appended \textbf{after} the existing ones, meaning they will be executed after the existing actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["on_event", {
    "event_1" : [
        Action,
            ...
    ],
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{on\_socketio} - adds several messages handlers to the simulated users state. If a given message handler already exists, new actions are appended \textbf{after} the existing ones, meaning they will be executed after the existing actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["on_socketio", {
    "opcode_1" : [
        Action,
            ...
    ],
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{emit\_event} - emits \texttt{Event} with \texttt{Args} as a Socket.IO message with the event opcode. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["emit_event", {
    "name" : Event,
    "args" : Args
}]
\end{minted}





\begin{itemize}
\item \texttt{emit\_socketio} - emits a Socket.IO message to the given \texttt{Endpoint} with the given \texttt{Opcode} and \texttt{Payload}. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["emit_socketio", {
    "opcode" : Opcode,
    "endpoint" : Endpoint,
    "data" : Payload
}]
\end{minted}





\begin{itemize}
\item \texttt{emit\_http} - emits a synchronous HTTP request with a given \texttt{Method}, \texttt{Body}, \texttt{Headers} and \texttt{Timeout} to a given \texttt{Url}. Afterwards, executes actions defined in \texttt{on\_reply} or \texttt{on\_error} when the requests succeeded or failed respectively. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["emit_http", {
    "url" : Url,
    "method" : Method,
    "body" : Body,
    "headers" : Headers,
    "timeout" : Timeout,

    "on_reply" : [
        Action,
        ...
    ],

    "on_error" : [
        Action,
        ...
    ]
}]
\end{minted}





\begin{itemize}
\item \texttt{match} - performs either a JSON-based or RegExp-based pattern-matching operation on \texttt{Subject}. RegExp-based matching takes precedence over JSON-based matching. The results are stored in the simulated users metadata under \texttt{Name\_\#} (where \# is the index of the match) for RegExp-based matching or under respective \texttt{\$names} for JSON-based matching. Afterwards, executes actions defined in either \texttt{on\_match} or \texttt{on\_nomatch} when the matching succeeds or fails respectively. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["match", {
    "name" : Name,
    "subject" : Subject,
    "re" : "regexp",

    "on_match" : [
        Action,
        ...
    ],

    "on_nomatch" : [
        Action,
        ...
    ]
}]

["match", {
    "subject" : Subject,
    "json" : {
        "field_1" : "$value_1",
        "field_2" : "$value_2",
        ...
    },

    "on_match" : [
        Action,
        ...
    ],

    "on_nomatch" : [
        Action,
        ...
    ]
}]
\end{minted}





\begin{itemize}
\item \texttt{case} - performs a value case dispatch on a given \texttt{Value} selecting a matching \texttt{Branch} and executing its respective actions. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["case", Value, {
    Branch : [
        Action,
        ...
    ],
    ...
}]
["case", {
    "condition" : Value,
    "branches" : {
        Branch : [
            Action,
            ...
        ],
        ...
    }
}]
\end{minted}





\begin{itemize}
\item \texttt{def} - adds new metadata to the simulated users state. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["def", {
    "key_1" : "value_1",
    "key_2" : "value_2",
    ...
}]
\end{minted}





\begin{itemize}
\item \texttt{terminate} - immediately stops actions execution and terminates the simulated user with termination reason set to \texttt{Reason}. Disconnects him from the server and terminates his process. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["terminate", Reason]
["terminate", {
    "reason" : Reason
}]
\end{minted}





\begin{itemize}
\item \texttt{log} - prints a log line to the console formatting it with the \texttt{Format} and \texttt{Values}. The \texttt{Format} format is the same as Erlangs \texttt{io:format/2} (why yes, I did lie about the ``no Erlang required'' thing, deal with it). Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["log", Format, Values]
["log", {
    "format" : Format,
    "values" : Values
}]
\end{minted}





\begin{itemize}
\item \texttt{!log} - a convenience action that allows easy \texttt{log} toggling; does nothing. Example usage:
\end{itemize}

\begin{minted}[]{javascript}
["!log", Format, Values]
["!log", {
    "format" : Format,
    "values" : Values
}]
\end{minted}
\subsection{Metadata}
\label{sec-3-6}
\label{ref-metadata}



\begin{itemize}
\item Metadata ordering
\item Introducing new metadata
\item JSON \$ubstitutions
\end{itemize}
\subsection{Example scenarios}
\label{sec-3-7}
\label{ref-example_scenarios}



\begin{itemize}
\item Sessions
\item Single ping
\item Continuous ping
\item ``3rd party'' requests
\end{itemize}

\pagebreak
\section{Flood results}
\label{sec-4}
\subsection{Results format}
\label{sec-4-1}


\begin{itemize}
\item JSON structure
\item Counters
\item Timers
\item Available statistics
\end{itemize}
\subsection{Goal schemas}
\label{sec-4-2}
\label{ref-goal_schemas}


\begin{itemize}
\item JSON Schema structure
\item Testing intervals
\item Reaching goals
\item Goal timeouts
\end{itemize}
\subsection{Continuous Integration integration}
\label{sec-4-3}


\begin{itemize}
\item Running Flood automagically
\end{itemize}
\subsection{Example results}
\label{sec-4-4}
\label{ref-example_results}



\begin{itemize}
\item Sessions
\item Single ping
\item Continuous ping
\item ``3rd party'' requests
\end{itemize}

\end{document}
